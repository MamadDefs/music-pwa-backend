"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const ws_1 = tslib_1.__importDefault(require("ws"));
const got_1 = tslib_1.__importDefault(require("got"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const core_1 = require("@oclif/core");
const update_notifier_1 = tslib_1.__importDefault(require("update-notifier"));
const https_proxy_agent_1 = tslib_1.__importDefault(require("https-proxy-agent"));
require("./interceptors");
const constants_1 = require("./constants");
update_notifier_1.default({ pkg: require('../package.json') }).notify({ isGlobal: true });
const isWin = os_1.default.platform() === 'win32';
class default_1 extends core_1.Command {
    constructor() {
        super(...arguments);
        this.got = got_1.default.extend();
    }
    async readGlobalConfig() {
        if (fs_extra_1.default.existsSync(constants_1.GLOBAL_CONF_PATH)) {
            fs_extra_1.default.removeSync(constants_1.PREVIOUS_GLOBAL_CONF_PATH);
            const content = fs_extra_1.default.readJSONSync(constants_1.GLOBAL_CONF_PATH, { throws: false }) || {};
            return content;
        }
        const content = fs_extra_1.default.readJSONSync(constants_1.PREVIOUS_GLOBAL_CONF_PATH, { throws: false }) || {};
        if (content.accounts && Object.keys(content.accounts).length) {
            const accounts = {};
            for (const account of Object.keys(content.accounts)) {
                await this.setGotConfig({
                    'api-token': content.accounts[account].api_token,
                    region: content.accounts[account].region,
                });
                try {
                    const { user: { email, fullname, avatar }, } = await this.got.get('v1/me').json();
                    accounts[account] = {
                        email,
                        avatar,
                        fullname,
                        region: content.accounts[account].region,
                        api_token: content.accounts[account].api_token,
                        current: content.current === account,
                    };
                }
                catch (error) {
                    if (!error.response) {
                        this.debug(error.stack);
                        this.error(error.message);
                    }
                }
            }
            return { version: constants_1.GLOBAL_CONF_VERSION, accounts };
        }
        if (content.api_token && content.region) {
            try {
                await this.setGotConfig({
                    'api-token': content.api_token,
                    region: content.region,
                });
                const { user: { email, fullname, avatar }, } = await this.got.get('v1/me').json();
                const accounts = {
                    [`${email.split('@')[0]}_${content.region}`]: {
                        email,
                        avatar,
                        fullname,
                        current: true,
                        region: content.region,
                        api_token: content.api_token,
                    },
                };
                return { version: constants_1.GLOBAL_CONF_VERSION, accounts };
            }
            catch (error) {
                if (error.response) {
                    return { version: constants_1.GLOBAL_CONF_VERSION, accounts: {} };
                }
                this.debug(error.stack);
                this.error(error.message);
            }
        }
        // For backward compatibility with < 1.0.0 versions
        // if (content && content.api_token) {
        //   content['api-token'] = content.api_token
        //   delete content.api_token
        // }
        return { version: constants_1.GLOBAL_CONF_VERSION, accounts: {} };
    }
    async catch(error) {
        if (error.code === 'ECONNREFUSED' || error.code === 'ECONNRESET') {
            this.error(`Could not connect to ${(error.config && error.config.baseURL) || 'https://api.liara.ir'}.
Please check your network connection.`);
        }
        if (error.oclif && error.oclif.exit === 0)
            return;
        this.error(error.message);
    }
    async setGotConfig(config) {
        const gotConfig = {
            headers: {
                'User-Agent': this.config.userAgent,
            },
            timeout: 10 * 1000,
        };
        const proxy = process.env.http_proxy || process.env.https_proxy;
        if (proxy && !isWin) {
            this.log(`Using proxy server ${proxy}`);
            // @ts-ignore
            const agent = new https_proxy_agent_1.default(proxy);
            gotConfig.agent = { https: agent };
        }
        if (!config['api-token'] || !config.region) {
            const { api_token, region } = await this.getCurrentAccount();
            config['api-token'] = config['api-token'] || api_token;
            config.region = config.region || region;
        }
        // @ts-ignore
        gotConfig.headers.Authorization = `Bearer ${config['api-token']}`;
        config.region = config.region || constants_1.FALLBACK_REGION;
        const actualBaseURL = constants_1.REGIONS_API_URL[config.region];
        gotConfig.prefixUrl = constants_1.DEV_MODE ? 'http://localhost:3000' : actualBaseURL;
        if (constants_1.DEV_MODE) {
            this.log(`[dev] The actual base url is: ${actualBaseURL}`);
            this.log(`[dev] but in dev mode we use http://localhost:3000`);
        }
        this.got = got_1.default.extend(gotConfig);
    }
    createProxiedWebsocket(endpoint) {
        const proxy = process.env.http_proxy || process.env.https_proxy;
        if (proxy && !isWin) {
            // @ts-ignore
            const agent = new https_proxy_agent_1.default(proxy);
            return new ws_1.default(endpoint, { agent });
        }
        return new ws_1.default(endpoint);
    }
    async promptProject() {
        this.spinner = ora_1.default();
        this.spinner.start('Loading...');
        try {
            const { projects } = await this.got('v1/projects').json();
            this.spinner.stop();
            if (!projects.length) {
                this.warn('Please go to https://console.liara.ir/apps and create an app, first.');
                this.exit(1);
            }
            const { project } = (await inquirer_1.default.prompt({
                name: 'project',
                type: 'list',
                message: 'Please select an app:',
                choices: [...projects.map((project) => project.project_id)],
            }));
            return project;
        }
        catch (error) {
            this.spinner.stop();
            throw error;
        }
    }
    async getCurrentAccount() {
        const accounts = (await this.readGlobalConfig()).accounts;
        const accName = Object.keys(accounts).find((account) => accounts[account].current);
        return Object.assign(Object.assign({}, accounts[accName || '']), { accountName: accName });
    }
}
exports.default = default_1;
default_1.flags = {
    help: core_1.Flags.help({ char: 'h' }),
    dev: core_1.Flags.boolean({ description: 'run in dev mode', hidden: true }),
    debug: core_1.Flags.boolean({ description: 'show debug logs' }),
    'api-token': core_1.Flags.string({
        description: 'your api token to use for authentication',
    }),
    region: core_1.Flags.string({
        description: 'the region you want to deploy your app to',
        options: ['iran', 'germany'],
    }),
};
