"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const base_1 = tslib_1.__importDefault(require("../../base"));
const core_1 = require("@oclif/core");
const constants_1 = require("../../constants");
const ws_1 = require("ws");
// TODO: detect and close broken connection with ping and pong
// https://www.npmjs.com/package/ws#how-to-detect-and-close-broken-connections
class AppShell extends base_1.default {
    async run() {
        const { flags } = await this.parse(AppShell);
        const config = this.getMergedConfig(flags);
        const CTRL_Q = '\u0011';
        await this.setGotConfig(config);
        const app = config.app || (await this.promptProject());
        const wsURL = constants_1.REGIONS_API_URL[config.region || constants_1.FALLBACK_REGION].replace('https://', 'wss://');
        const ws = this.createProxiedWebsocket(`${wsURL}/v1/exec?token=${config['api-token']}&cmd=${flags.command}&project_id=${app}`);
        const duplex = ws_1.createWebSocketStream(ws, { encoding: 'utf8' });
        const isRaw = process.stdin.isTTY;
        const clearStdinEffects = () => {
            process.stdin.removeAllListeners();
            isRaw && process.stdin.setRawMode(isRaw);
            process.stdin.resume();
        };
        ws.on('open', () => {
            isRaw && process.stdin.setRawMode(true);
            process.stdin.setEncoding('utf8');
            process.stdin.resume();
            process.stdin.pipe(duplex);
            duplex.pipe(process.stdout);
            process.stdin.on('data', function (key) {
                if (key.toString() === CTRL_Q) {
                    clearStdinEffects();
                    ws.terminate();
                    process.exit(0);
                }
            });
        });
        ws.on('close', () => {
            clearStdinEffects();
            process.exit(0);
        });
        ws.on('unexpected-response', (response) => {
            var _a;
            // @ts-ignore
            const statusCode = (_a = response.socket) === null || _a === void 0 ? void 0 : _a._httpMessage.res.statusCode;
            statusCode === 404 &&
                console.error(new core_1.Errors.CLIError(`app '${app}' not found.`).render());
            clearStdinEffects();
            process.exit(2);
        });
        ws.on('error', (err) => {
            console.error(new core_1.Errors.CLIError(`Unexpected Error: ${err.message}`).render());
            clearStdinEffects();
            process.exit(2);
        });
    }
    getMergedConfig(flags) {
        const defaults = {
            path: flags.path ? flags.path : process.cwd(),
        };
        const projectConfig = this.readProjectConfig(defaults.path);
        return Object.assign(Object.assign(Object.assign({}, defaults), projectConfig), flags);
    }
    readProjectConfig(projectPath) {
        let content;
        const liaraJSONPath = path_1.default.join(projectPath, 'liara.json');
        const hasLiaraJSONFile = fs_extra_1.default.existsSync(liaraJSONPath);
        if (hasLiaraJSONFile) {
            try {
                content = fs_extra_1.default.readJSONSync(liaraJSONPath) || {};
            }
            catch (_a) {
                this.error('Syntax error in `liara.json`!');
            }
        }
        return content || {};
    }
}
exports.default = AppShell;
AppShell.description = 'run a command in a running applet';
AppShell.flags = Object.assign(Object.assign({}, base_1.default.flags), { app: core_1.Flags.string({
        char: 'a',
        description: 'app id',
    }), command: core_1.Flags.string({
        char: 'c',
        description: 'the command to execute',
        default: '/bin/bash',
    }) });
AppShell.aliases = ['shell'];
