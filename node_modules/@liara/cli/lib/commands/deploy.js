"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ora_1 = tslib_1.__importDefault(require("ora"));
const path_1 = tslib_1.__importDefault(require("path"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const bytes_1 = tslib_1.__importDefault(require("bytes"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const moment_1 = tslib_1.__importDefault(require("moment"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const progress_1 = tslib_1.__importDefault(require("progress"));
const core_1 = require("@oclif/core");
const logs_1 = tslib_1.__importDefault(require("./app/logs"));
const base_1 = tslib_1.__importDefault(require("../base"));
const poller_1 = tslib_1.__importDefault(require("../utils/poller"));
const upload_1 = tslib_1.__importDefault(require("../services/upload"));
const check_path_1 = tslib_1.__importDefault(require("../utils/check-path"));
const on_intrupt_1 = tslib_1.__importDefault(require("../utils/on-intrupt"));
const build_logs_1 = tslib_1.__importDefault(require("../services/build-logs"));
const build_failed_1 = tslib_1.__importDefault(require("../errors/build-failed"));
const validate_port_1 = tslib_1.__importDefault(require("../utils/validate-port"));
const build_cancel_1 = tslib_1.__importDefault(require("../errors/build-cancel"));
const build_timeout_1 = tslib_1.__importDefault(require("../errors/build-timeout"));
const output_1 = require("../utils/output");
const create_archive_1 = tslib_1.__importDefault(require("../utils/create-archive"));
const release_failed_1 = tslib_1.__importDefault(require("../errors/release-failed"));
const tmp_dir_1 = tslib_1.__importDefault(require("../services/tmp-dir"));
const detect_platform_1 = tslib_1.__importDefault(require("../utils/detect-platform"));
const collect_git_info_1 = tslib_1.__importDefault(require("../utils/collect-git-info"));
const build_args_parser_1 = tslib_1.__importDefault(require("../utils/build-args-parser"));
const constants_1 = require("../constants");
const deploy_exception_1 = tslib_1.__importDefault(require("../errors/deploy-exception"));
const get_port_1 = require("../utils/get-port");
const cancel_deployment_1 = tslib_1.__importDefault(require("../services/cancel-deployment"));
const max_source_size_1 = tslib_1.__importDefault(require("../errors/max-source-size"));
const merge_platform_config_1 = tslib_1.__importDefault(require("../utils/merge-platform-config"));
class Deploy extends base_1.default {
    async run() {
        const { flags } = await this.parse(Deploy);
        const config = this.getMergedConfig(flags);
        const debug = output_1.createDebugLogger(flags.debug);
        this.debug = debug;
        this.spinner = ora_1.default();
        if (!config.image) {
            try {
                check_path_1.default(config.path);
            }
            catch (error) {
                this.error(error.message);
            }
            this.dontDeployEmptyProjects(config.path);
        }
        await this.setGotConfig(config);
        this.validateDeploymentConfig(config);
        let isPlatformDetected = false;
        if (!config.image) {
            if (!config.platform) {
                try {
                    config.platform = detect_platform_1.default(config.path);
                    isPlatformDetected = true;
                }
                catch (error) {
                    return this.error(error.message);
                }
            }
            this.validatePlatform(config.platform, config.path);
        }
        else {
            config.platform = 'docker';
        }
        if (!config.app) {
            config.app = await this.promptProject();
        }
        if (!config.port) {
            config.port =
                get_port_1.getPort(config.platform) || (await this.promptPort(config.platform));
        }
        this.logKeyValue('App', config.app);
        this.logKeyValue('Path', config.path);
        isPlatformDetected
            ? this.logKeyValue('Detected platform', config.platform)
            : this.logKeyValue('Platform', config.platform);
        this.logKeyValue('Port', String(config.port));
        if (config.disks) {
            this.logKeyValue('Disks');
            for (const disk of config.disks) {
                console.log(`  ${disk.name} ${chalk_1.default.blue('->')} ${disk.mountTo}`);
            }
        }
        if (config['no-cache'] || config.buildCache === false) {
            this.debug('Using Build Cache: Disabled');
        }
        if (!config['no-cache'] &&
            (config.buildCache || config.buildCache === undefined)) {
            config.buildCache = true;
            this.debug('Using Build Cache: Enabled');
        }
        if (Array.isArray(config['build-arg'])) {
            // @ts-ignore
            config['build-arg'] = build_args_parser_1.default(config['build-arg']);
        }
        try {
            const response = await this.deploy(config);
            !config.image && (await this.showBuildLogs(response.releaseID));
            config.image && (await this.showReleaseLogs(response.releaseID));
            this.log();
            this.log(chalk_1.default.green('Deployment finished successfully.'));
            this.log(chalk_1.default.white('Open up the url below in your browser:'));
            this.log();
            const defaultSubdomain = config.region === 'iran' ? '.iran.liara.run' : '.liara.run';
            const urlLogMessage = constants_1.DEV_MODE
                ? // tslint:disable-next-line: no-http-string
                    `    ${chalk_1.default.cyan(`http://${config.app}.liara.localhost`)}`
                : `    ${chalk_1.default.cyan(`https://${config.app}${defaultSubdomain}`)}`;
            this.log(urlLogMessage);
            this.log();
            if (flags.detach) {
                process.exit(0);
            }
            this.log('Reading app logs...');
            await logs_1.default.run([
                '--app',
                config.app,
                '--since',
                moment_1.default().unix().toString(),
                '--api-token',
                config['api-token'] || '',
                '--region',
                config.region || '',
            ]);
        }
        catch (error) {
            this.log();
            this.spinner.stop();
            error.response && debug(error.response.body);
            !error.response && debug(error);
            const responseBody = error.response &&
                error.response.statusCode >= 400 &&
                error.response.statusCode < 500
                ? JSON.parse(error.response.body)
                : {};
            if (error.message === 'TIMEOUT') {
                this.error('Build timed out. It took about 10 minutes.');
            }
            if (error.response &&
                error.response.statusCode === 404 &&
                responseBody.message === 'project_not_found') {
                const message = `App does not exist.
Please open up https://console.liara.ir/apps and create the app, first.`;
                return this.error(message);
            }
            if (error.response &&
                error.response.statusCode === 400 &&
                responseBody.message === 'frozen_project') {
                const message = `App is frozen (not enough balance).
Please open up https://console.liara.ir/apps and unfreeze the app.`;
                return this.error(message);
            }
            if (error.response &&
                error.response.statusCode >= 400 &&
                error.response.statusCode < 500 &&
                responseBody.message) {
                const message = `CODE ${error.response.statusCode}: ${responseBody.message}`;
                return this.error(message);
            }
            if (error.response && error.response.statusCode === 401) {
                // tslint:disable-next-line: no-console
                console.error(new core_1.Errors.CLIError(`Authentication failed.
Please login via 'liara login' command.

If you are using API token for authentication, please consider updating your API token.
You may also want to switch to another region. Your current region is: ${chalk_1.default.cyan(config.region)}`).render());
                process.exit(2);
            }
            if (error instanceof max_source_size_1.default) {
                this.error(`Source is too large. ${chalk_1.default.yellowBright('(max: 256MB)')}`);
            }
            this.log(chalk_1.default.gray(this.config.userAgent));
            this.log();
            this.error(`Deployment failed.
Sorry for inconvenience. If you think it's a bug, please contact us.
To file a ticket, please head to: https://console.liara.ir/tickets`);
        }
    }
    async deploy(config) {
        const body = {
            build: {
                cache: config.buildCache,
            },
            cron: config.cron,
            args: config.args,
            port: config.port,
            type: config.platform,
            message: config.message,
            disks: config.disks,
        };
        if (config.image) {
            body.image = config.image;
            return this.createRelease(config.app, body);
        }
        if (config['build-arg']) {
            body.build.args = config['build-arg'];
        }
        body.gitInfo = await collect_git_info_1.default(config.path, this.debug);
        // @ts-ignore
        body.platformConfig = await merge_platform_config_1.default(config.path, 
        // @ts-ignore
        config.platform, 
        // @ts-ignore
        config[config.platform] || {}, this.debug);
        if (config.healthCheck) {
            body.healthCheck = config.healthCheck;
            if (typeof config.healthCheck.command === 'string') {
                body.healthCheck.command = config.healthCheck.command.split(' ');
            }
        }
        this.spinner.start('Creating an archive...');
        const sourcePath = tmp_dir_1.default();
        await create_archive_1.default(sourcePath, config.path, config.platform, this.debug);
        this.spinner.stop();
        const { size: sourceSize } = fs_extra_1.default.statSync(sourcePath);
        this.logKeyValue('Compressed size', `${bytes_1.default(sourceSize)} ${chalk_1.default.cyanBright('(use .gitignore to reduce the size)')}`);
        if (sourceSize > constants_1.MAX_SOURCE_SIZE) {
            try {
                fs_extra_1.default.removeSync(sourcePath);
            }
            catch (error) {
                this.debug(error.stack);
            }
            finally {
                // eslint-disable-next-line no-unsafe-finally
                throw new max_source_size_1.default();
            }
        }
        const sourceID = await this.upload(config.app, sourcePath, sourceSize);
        this.debug(`sourceID: ${sourceID}`);
        body.sourceID = sourceID;
        return this.createRelease(config.app, body);
    }
    createRelease(project, body) {
        return this.got
            .post(`v2/projects/${project}/releases`, { json: body })
            .json();
    }
    async showBuildLogs(releaseID) {
        this.spinner.start('Building...');
        let isCanceled = false;
        const removeInterupListener = on_intrupt_1.default(async () => {
            // Force close
            if (isCanceled)
                process.exit(3);
            this.spinner.start('\nCanceling the build...');
            isCanceled = true;
            const retryOptions = {
                retries: 3,
                onRetry: (error, attempt) => {
                    this.debug(error.stack);
                    this.log(`${attempt}: Could not cancel, retrying...`);
                },
            };
            await cancel_deployment_1.default(this.got, releaseID, retryOptions);
            this.spinner.warn('Build canceled.');
            process.exit(3);
        });
        try {
            await build_logs_1.default(this.got, releaseID, isCanceled, (output) => {
                if (output.state === 'DEPLOYING') {
                    this.spinner.succeed('Image pushed.');
                    this.spinner.start('Creating a new release...');
                }
                if (output.state === 'BUILDING' && output.line) {
                    this.spinner.clear().frame();
                    process.stdout.write(output.line);
                }
                if (output.state === 'PUSHING') {
                    this.spinner.succeed('Build finished.');
                    this.spinner.start('Pushing the image...');
                    removeInterupListener();
                }
            });
            this.spinner.succeed('Release created.');
        }
        catch (error) {
            if (error instanceof build_failed_1.default) {
                // tslint:disable-next-line: no-console
                console.error(error.output.line);
                throw new Error('Build failed.');
            }
            if (error instanceof build_cancel_1.default) {
                this.spinner.warn('Build canceled.');
                process.exit(3);
            }
            if (error instanceof build_timeout_1.default) {
                this.spinner.fail();
                throw new Error('TIMEOUT');
            }
            if (error instanceof deploy_exception_1.default) {
                this.spinner.fail();
                throw new Error(this.parseFailReason(error.message));
            }
            if (error instanceof release_failed_1.default) {
                this.spinner.fail();
                throw new Error('Release failed.');
            }
            this.debug(error.stack);
        }
    }
    async showReleaseLogs(releaseID) {
        this.spinner.start('Creating a new release...');
        return new Promise((resolve, reject) => {
            const poller = new poller_1.default();
            poller.onPoll(async () => {
                try {
                    const { release } = await this.got(`v1/releases/${releaseID}`).json();
                    if (release.state === 'FAILED') {
                        this.spinner.fail();
                        if (release.failReason) {
                            return reject(new deploy_exception_1.default(this.parseFailReason(release.failReason)));
                        }
                        return reject(new Error('Release failed.'));
                    }
                    if (release.state === 'READY') {
                        this.spinner.succeed('Release created.');
                        return resolve();
                    }
                }
                catch (error) {
                    this.debug(error.stack);
                }
                poller.poll();
            });
            poller.poll();
        });
    }
    parseFailReason(reason) {
        const [errorName, ...data] = reason.split(' ');
        if (errorName === 'disk_not_found') {
            return `Could not find disk \`${data[0]}\`.`;
        }
        return reason;
    }
    dontDeployEmptyProjects(projectPath) {
        if (fs_extra_1.default.readdirSync(projectPath).length === 0) {
            this.error('Directory is empty!');
        }
    }
    logKeyValue(key, value = '') {
        this.spinner.clear().frame();
        this.log(`${chalk_1.default.blue(`${key}:`)} ${value}`);
    }
    validateDeploymentConfig(config) {
        if (config.healthCheck && !config.healthCheck.command) {
            this.error('`command` field in healthCheck is required.');
        }
        if (config.healthCheck &&
            typeof config.healthCheck.command !== 'string' &&
            !Array.isArray(config.healthCheck.command)) {
            this.error('`command` field in healthCheck must be either an array or a string.');
        }
        if (config.buildCache !== undefined &&
            typeof config.buildCache !== 'boolean') {
            this.error('`buildCache` field must be a boolean.');
        }
    }
    async promptProject() {
        this.spinner.start('Loading...\n');
        try {
            const { projects } = await this.got('v1/projects').json();
            this.spinner.stop();
            if (!projects.length) {
                this.warn('Please go to https://console.liara.ir/apps and create an app, first.');
                this.exit(1);
            }
            const { project } = (await inquirer_1.default.prompt({
                name: 'project',
                type: 'list',
                message: 'Please select an app:',
                choices: [...projects.map((project) => project.project_id)],
            }));
            return project;
        }
        catch (error) {
            this.spinner.stop();
            throw error;
        }
    }
    async promptPort(platform) {
        const { port } = (await inquirer_1.default.prompt({
            name: 'port',
            type: 'input',
            default: get_port_1.getDefaultPort(platform),
            message: 'Enter the port your app listens to:',
            validate: validate_port_1.default,
        }));
        return port;
    }
    getMergedConfig(flags) {
        const defaults = {
            path: flags.path ? flags.path : process.cwd(),
        };
        const projectConfig = this.readProjectConfig(defaults.path);
        const disks = flags.disks
            ? flags.disks.map((el) => {
                const [name, mountTo] = el.toString().split(':');
                return { name, mountTo };
            })
            : projectConfig.disks;
        return Object.assign(Object.assign(Object.assign(Object.assign({}, defaults), projectConfig), flags), { disks });
    }
    readProjectConfig(projectPath) {
        let content;
        const liaraJSONPath = path_1.default.join(projectPath, 'liara.json');
        const hasLiaraJSONFile = fs_extra_1.default.existsSync(liaraJSONPath);
        if (hasLiaraJSONFile) {
            try {
                content = fs_extra_1.default.readJSONSync(liaraJSONPath) || {};
            }
            catch (_a) {
                this.error('Syntax error in `liara.json`!');
            }
        }
        return content || {};
    }
    validatePlatform(platform, projectPath) {
        if (platform === 'node') {
            const packageJSON = fs_extra_1.default.readJSONSync(path_1.default.join(projectPath, 'package.json'));
            if (!packageJSON.scripts || !packageJSON.scripts.start) {
                this.error(`A NodeJS app must be runnable with 'npm start'.
You must add a 'start' command to your package.json scripts.`);
            }
        }
    }
    async upload(project, sourcePath, sourceSize) {
        const bar = new progress_1.default('Uploading [:bar] :percent :etas', {
            total: sourceSize,
            width: 20,
            complete: '=',
            incomplete: '',
            clear: true,
        });
        const onProgress = (progress) => {
            bar.tick(progress.transferred - bar.curr);
        };
        try {
            const response = await upload_1.default(project, this.got, sourcePath)
                .on('uploadProgress', onProgress)
                .json();
            this.spinner.succeed('Upload finished.');
            this.debug(`source upload response: ${JSON.stringify(response)}`);
            return response.sourceID;
        }
        catch (error) {
            this.spinner.fail('Upload failed.');
            throw error;
        }
        finally {
            // cleanup
            fs_extra_1.default.unlink(sourcePath).catch(() => { });
        }
    }
}
exports.default = Deploy;
Deploy.description = 'deploy an app';
Deploy.flags = Object.assign(Object.assign({}, base_1.default.flags), { path: core_1.Flags.string({ description: 'app path in your computer' }), platform: core_1.Flags.string({
        description: 'the platform your app needs to run',
    }), app: core_1.Flags.string({ char: 'a', description: 'app id' }), port: core_1.Flags.integer({
        char: 'p',
        description: 'the port that your app listens to',
    }), image: core_1.Flags.string({ char: 'i', description: 'docker image to deploy' }), detach: core_1.Flags.boolean({
        description: 'do not stream app logs after deployment',
        default: false,
    }), args: core_1.Flags.string({
        description: 'docker image entrypoint args',
        multiple: true,
    }), 'build-arg': core_1.Flags.string({
        description: 'docker image build args',
        multiple: true,
    }), message: core_1.Flags.string({ char: 'm', description: 'the release message' }), disks: core_1.Flags.string({
        char: 'd',
        description: 'mount a disk',
        multiple: true,
    }), 'no-cache': core_1.Flags.boolean({
        description: 'do not use cache when building the image',
    }) });
