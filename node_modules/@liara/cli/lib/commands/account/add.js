"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const got_1 = tslib_1.__importDefault(require("got"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const use_1 = tslib_1.__importDefault(require("./use"));
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const base_1 = tslib_1.__importDefault(require("../../base"));
const inquirer_1 = require("inquirer");
const core_1 = require("@oclif/core");
const interceptors_1 = tslib_1.__importDefault(require("../../interceptors"));
const email_prompt_ts_1 = tslib_1.__importDefault(require("email-prompt-ts"));
const erase_lines_1 = tslib_1.__importDefault(require("../../utils/erase-lines"));
const output_1 = require("../../utils/output");
const email_validator_1 = require("email-validator");
const constants_1 = require("../../constants");
class AccountAdd extends base_1.default {
    async run() {
        const { flags } = await this.parse(AccountAdd);
        const debug = output_1.createDebugLogger(flags.debug);
        const liara_json = await this.readGlobalConfig();
        const currentAccounts = liara_json.accounts;
        const region = flags.region || constants_1.FALLBACK_REGION;
        if (!flags.email) {
            let emailIsValid = false;
            do {
                flags.email = await this.promptEmail();
                emailIsValid = email_validator_1.validate(flags.email);
                if (!emailIsValid) {
                    process.stdout.write(erase_lines_1.default(1));
                }
            } while (!emailIsValid);
            this.log();
        }
        const body = {
            email: flags.email,
            password: flags.password ||
                (!flags['api-token'] && (await this.promptPassword())),
        };
        if (flags['from-login']) {
            flags.account = `${flags.email.split('@')[0]}_${region}`;
        }
        const name = flags.account || (await this.promptName(flags.email, region));
        this.got = got_1.default.extend({ prefixUrl: constants_1.REGIONS_API_URL[region], hooks: interceptors_1.default });
        const { api_token, fullname, avatar } = (await async_retry_1.default(async () => {
            try {
                const data = await this.got
                    .post('v1/login', {
                    json: body,
                    headers: { Authorization: undefined },
                })
                    .json();
                return data;
            }
            catch (error) {
                debug('retrying...');
                throw error;
            }
        }, { retries: 3 }));
        const accounts = Object.assign(Object.assign({}, currentAccounts), { [name]: {
                email: body.email,
                api_token,
                region,
                fullname,
                avatar,
                current: false,
            } });
        fs_extra_1.default.writeFileSync(constants_1.GLOBAL_CONF_PATH, JSON.stringify({ accounts, version: constants_1.GLOBAL_CONF_VERSION }));
        flags['from-login'] && (await use_1.default.run(['--account', name]));
        const { accountName } = await this.getCurrentAccount();
        this.log(`> Auth credentials saved in ${chalk_1.default.bold(constants_1.GLOBAL_CONF_PATH)}`);
        accountName && this.log(`> Current account is: ${accountName}`);
    }
    async promptName(email, region) {
        const { name } = (await inquirer_1.prompt({
            name: 'name',
            type: 'input',
            message: 'Enter an optional name for this account:',
            default: `${email.split('@')[0]}_${region}`,
        }));
        const liara_json = await this.readGlobalConfig();
        const currentAccounts = liara_json.accounts;
        const currentAccountsName = currentAccounts && Object.keys(currentAccounts);
        return (currentAccountsName === null || currentAccountsName === void 0 ? void 0 : currentAccountsName.includes(name)) ? this.error('This name has already been used for another account. Please use a different name.')
            : name;
    }
    async promptEmail() {
        try {
            return await email_prompt_ts_1.default({
                start: `${chalk_1.default.green('?')} ${chalk_1.default.bold('Enter your email:')} `,
            });
        }
        catch (error) {
            this.log(); // \n
            if (error.message === 'User abort') {
                process.stdout.write(erase_lines_1.default(2));
                console.log(`${chalk_1.default.red('> Aborted!')} No changes made.`);
                process.exit(0);
            }
            if (error.message === 'stdin lacks setRawMode support') {
                this.error(`Interactive mode not supported â€“ please run ${chalk_1.default.green('liara login --email you@domain.com --password your_password')}`);
            }
            throw error;
        }
    }
    async promptPassword() {
        const { password } = (await inquirer_1.prompt({
            name: 'password',
            type: 'password',
            message: 'Enter your password:',
            validate(input) {
                if (input.length === 0) {
                    return false;
                }
                return true;
            },
        }));
        return password;
    }
}
exports.default = AccountAdd;
AccountAdd.description = 'add an account';
AccountAdd.flags = Object.assign(Object.assign({}, base_1.default.flags), { email: core_1.Flags.string({ char: 'e', description: 'your email' }), password: core_1.Flags.string({ char: 'p', description: 'your password' }), account: core_1.Flags.string({
        char: 'a',
        description: 'account name',
        required: false,
    }), 'from-login': core_1.Flags.boolean({
        required: false,
        hidden: true,
        default: false,
    }) });
