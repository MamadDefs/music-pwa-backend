"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const poller_1 = tslib_1.__importDefault(require("../utils/poller"));
const build_failed_1 = tslib_1.__importDefault(require("../errors/build-failed"));
const build_cancel_1 = tslib_1.__importDefault(require("../errors/build-cancel"));
const build_timeout_1 = tslib_1.__importDefault(require("../errors/build-timeout"));
const deploy_exception_1 = tslib_1.__importDefault(require("../errors/deploy-exception"));
const release_failed_1 = tslib_1.__importDefault(require("../errors/release-failed"));
exports.default = async (httpClient, releaseID, isCanceled, cb) => {
    return new Promise((resolve, reject) => {
        const poller = new poller_1.default();
        let since;
        let isDeploying = false;
        poller.onPoll(async () => {
            try {
                const { release, buildOutput } = await httpClient
                    .get(`v2/releases/${releaseID}/build-logs?since=${since}`)
                    .json();
                for (const output of buildOutput) {
                    if (output.stream === 'STDOUT') {
                        cb({ state: 'BUILDING', line: output.line });
                    }
                    else {
                        return reject(new build_failed_1.default('Build failed', output));
                    }
                }
                if (!buildOutput.length) {
                    if (release.state === 'CANCELED') {
                        return reject(new build_cancel_1.default(''));
                    }
                    if (release.state === 'TIMEDOUT') {
                        return reject(new build_timeout_1.default('TIMEOUT'));
                    }
                    if (release.state === 'FAILED') {
                        if (release.failReason) {
                            return reject(new deploy_exception_1.default(release.failReason));
                        }
                        return reject(new release_failed_1.default('Release failed.'));
                    }
                    if (release.state === 'DEPLOYING' && !isDeploying) {
                        isDeploying = true;
                        cb({ state: 'DEPLOYING' });
                    }
                    if (release.state === 'READY') {
                        return resolve();
                    }
                }
                if (buildOutput.length) {
                    const lastLine = buildOutput[buildOutput.length - 1];
                    since = lastLine.createdAt;
                    if (lastLine.line.startsWith('Successfully tagged')) {
                        cb({ state: 'PUSHING' });
                    }
                }
            }
            catch (_a) { }
            !isCanceled && poller.poll();
        });
        !isCanceled && poller.poll();
    });
};
